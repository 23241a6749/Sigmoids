import express from 'express';
import mongoose from 'mongoose';
import crypto from 'crypto';
import Razorpay from 'razorpay';
import { Bill } from '../models/Bill.js';
import { Product } from '../models/Product.js';
import { Customer } from '../models/Customer.js';
import { CustomerAccount } from '../models/CustomerAccount.js';
import { LedgerEntry } from '../models/LedgerEntry.js';
import { OTP } from '../models/OTP.js';
import { auth } from '../middleware/auth.js';
import { recalculateGlobalKhataScore } from '../utils/khataScore.js';
import twilio from 'twilio';

const router = express.Router();

// ── LAZY INITIALIZATION HELPERS ──────────────────────────────────────────
// In ESM, top-level code runs before dotenv.config() in index.ts. 
// These helpers ensure env vars are actually loaded before we use them.

let _twilioClient: any = null;
function getTwilioClient() {
    if (!_twilioClient) {
        if (!process.env.TWILIO_ACCOUNT_SID || !process.env.TWILIO_AUTH_TOKEN) {
            console.error('[Twilio] CRITICAL: SID or TOKEN missing in .env');
            return null;
        }
        _twilioClient = twilio(process.env.TWILIO_ACCOUNT_SID, process.env.TWILIO_AUTH_TOKEN);
    }
    return _twilioClient;
}

let _razorpay: any = null;
function getRazorpay() {
    if (!_razorpay) {
        if (!process.env.RAZORPAY_KEY_ID || !process.env.RAZORPAY_KEY_SECRET) {
            console.error('[Razorpay] CRITICAL: Key ID or Secret missing in .env');
            return null;
        }
        _razorpay = new Razorpay({
            key_id: process.env.RAZORPAY_KEY_ID,
            key_secret: process.env.RAZORPAY_KEY_SECRET
        });
    }
    return _razorpay;
}

// Helper function to create a bill (reusable)
async function createBillInternal(session: mongoose.ClientSession, data: any, userId: string) {
    const { customerPhoneNumber: rawPhone, customerName, items, paymentType } = data;
    const customerPhoneNumber = rawPhone.startsWith('+91') ? rawPhone : '+91' + rawPhone.replace(/\D/g, '').slice(-10);

    // 1. Find or Create Customer
    let customer = await Customer.findOne({ phoneNumber: customerPhoneNumber }).session(session);
    if (!customer) {
        customer = new Customer({
            phoneNumber: customerPhoneNumber,
            name: customerName || ''
        });
        await customer.save({ session });
    } else if (customerName && !customer.name) {
        customer.name = customerName;
        await customer.save({ session });
    }

    let totalAmount = 0;
    const processedItems = [];

    // 2. Validate Stock and Calculate Total
    for (const item of items) {
        const product = await Product.findById(item.productId).session(session);
        if (!product) throw new Error(`Product ${item.productId} not found`);
        if (product.stock < item.quantity) throw new Error(`Insufficient stock for ${product.name}`);

        product.stock -= item.quantity;
        await product.save({ session });

        totalAmount += product.price * item.quantity;
        processedItems.push({
            productId: product._id,
            name: product.name,
            quantity: item.quantity,
            price: product.price
        });
    }

    // 3. Create Bill
    const bill = new Bill({
        shopkeeperId: userId,
        customerId: customer._id,
        items: processedItems,
        totalAmount,
        paymentType
    });
    await bill.save({ session });

    // 4. Handle Ledger if applicable
    if (paymentType === 'ledger') {
        const ledgerEntry = new LedgerEntry({
            shopkeeperId: userId,
            customerId: customer._id,
            billId: bill._id,
            amount: totalAmount,
            type: 'debit',
            status: 'pending'
        });
        await ledgerEntry.save({ session });

        let account = await CustomerAccount.findOne({
            customerId: customer._id,
            shopkeeperId: userId
        }).session(session);

        if (!account) {
            account = new CustomerAccount({
                customerId: customer._id,
                shopkeeperId: userId,
                balance: totalAmount
            });
        } else {
            account.balance += totalAmount;
        }
        await account.save({ session });
    }

    // Recalculate Global Khata Score after any transaction (new debt or cash purchase)
    recalculateGlobalKhataScore(customer._id.toString()).catch(err => console.error('Score calculation error:', err));

    return bill;
}

// Create a new bill (Cash/Online)
router.post('/', auth, async (req, res) => {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        if (req.body.paymentType === 'ledger') {
            throw new Error('Ledger payments require OTP verification');
        }

        if (!req.auth?.userId) throw new Error('Authentication required');
        const bill = await createBillInternal(session, req.body, req.auth.userId);
        await session.commitTransaction();
        res.status(201).json(bill);
    } catch (err: any) {
        await session.abortTransaction();
        res.status(400).json({ message: err.message });
    } finally {
        session.endSession();
    }
});

// Send OTP for Khata payment
router.post('/khata/send-otp', auth, async (req, res) => {
    try {
        const { customerPhoneNumber: rawPhone } = req.body;
        if (!rawPhone) return res.status(400).json({ message: 'Phone number is required' });
        const customerPhoneNumber = rawPhone.startsWith('+91') ? rawPhone : '+91' + rawPhone.replace(/\D/g, '').slice(-10);

        const otp = Math.floor(100000 + Math.random() * 900000).toString();
        const expiresAt = new Date(Date.now() + 5 * 60 * 1000);

        await OTP.findOneAndUpdate(
            { phoneNumber: customerPhoneNumber },
            { otp, expiresAt, attempts: 0 },
            { upsert: true }
        );

        // ── ALWAYS log OTP to console first so it's visible even if Twilio fails ──
        console.log(`\n╔══════════════════════════════════════╗`);
        console.log(`║  [KHATA OTP]  ${otp}                   ║`);
        console.log(`║  Phone: ${customerPhoneNumber}  ║`);
        console.log(`╚══════════════════════════════════════╝\n`);

        // ── Try to send via Twilio ──────────────────────────────────────────────
        const whatsappNum = process.env.TWILIO_WHATSAPP_NUMBER || process.env.TWILIO_PHONE_NUMBER;
        const smsNum = process.env.TWILIO_SMS_NUMBER || process.env.TWILIO_PHONE_NUMBER;

        if (whatsappNum || smsNum) {
            const isWhatsApp = whatsappNum?.startsWith('whatsapp:');
            const from = isWhatsApp ? whatsappNum : smsNum;

            const cleanPhone = customerPhoneNumber.replace(/\D/g, '').slice(-10);
            const to = isWhatsApp ? `whatsapp:+91${cleanPhone}` : `+91${cleanPhone}`;

            if (isWhatsApp) {
                // ⚠️  Twilio WhatsApp SANDBOX requires the recipient to first send
                //     "join <sandbox-word>" to +14155238886 from their WhatsApp.
                //     If they haven't done that, the message will silently fail.
                //     Either ask the customer to join, or switch to SMS by setting
                //     TWILIO_SMS_NUMBER to a Twilio SMS number (no 'whatsapp:' prefix).
                console.log(`[Twilio] Sending WhatsApp OTP to ${to} — recipient must have joined the sandbox.`);
            } else {
                console.log(`[Twilio] Sending SMS OTP to ${to}`);
            }

            try {
                const client = getTwilioClient();
                if (!client) throw new Error('Twilio client not initialized');

                await client.messages.create({
                    body: `[KLink] Your Khata OTP is: ${otp}. Valid for 5 mins. Do not share.`,
                    from: from,
                    to: to
                });
                console.log('[Twilio] ✅ Message sent successfully');
            } catch (twilioErr: any) {
                // Log full Twilio error — the OTP is still in DB so manual entry works
                console.error('[Twilio] ❌ Failed to send message:');
                console.error('  Code   :', twilioErr.code);
                console.error('  Message:', twilioErr.message);
                console.error('  More   :', twilioErr.moreInfo);
                // Do NOT throw — the OTP is stored in DB so the user can still enter it
            }
        }

        res.json({ message: 'OTP sent' });
    } catch (err: any) {
        res.status(500).json({ message: 'Failed to send OTP' });
    }
});

// Verify OTP and complete Khata payment
router.post('/khata/verify-otp', auth, async (req, res) => {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        const { customerPhoneNumber: rawPhone, otp, billData } = req.body;
        const customerPhoneNumber = rawPhone.startsWith('+91') ? rawPhone : '+91' + rawPhone.replace(/\D/g, '').slice(-10);

        const otpRecord = await OTP.findOne({ phoneNumber: customerPhoneNumber });
        if (!otpRecord) throw new Error('OTP expired or not requested');

        if (otpRecord.attempts >= 3) {
            await OTP.deleteOne({ phoneNumber: customerPhoneNumber });
            throw new Error('Max attempts reached. Please resend OTP.');
        }

        // Check expiry
        if (otpRecord.expiresAt < new Date()) {
            await OTP.deleteOne({ phoneNumber: customerPhoneNumber });
            throw new Error('OTP has expired. Please request a new one.');
        }

        if (otpRecord.otp !== otp) {
            otpRecord.attempts += 1;
            await otpRecord.save();
            throw new Error('Invalid OTP');
        }

        await OTP.deleteOne({ phoneNumber: customerPhoneNumber });

        if (!req.auth?.userId) throw new Error('Authentication required');
        const bill = await createBillInternal(session, { ...billData, paymentType: 'ledger' }, req.auth.userId);
        await session.commitTransaction();
        res.status(201).json(bill);
    } catch (err: any) {
        await session.abortTransaction();
        res.status(400).json({ message: err.message });
    } finally {
        session.endSession();
    }
});

// Diagnostic route
router.get('/test-razorpay', (req, res) => {
    res.json({
        keyId: process.env.RAZORPAY_KEY_ID,
        isLive: process.env.RAZORPAY_KEY_ID?.startsWith('rzp_live'),
        envExists: !!process.env.RAZORPAY_KEY_ID
    });
});

// ─────────────────────────────────────────────
// RAZORPAY: Create Order
// Frontend calls this to get an order_id before opening the checkout popup.
// ─────────────────────────────────────────────
router.post('/razorpay/create-order', auth, async (req, res) => {
    try {
        const { amount } = req.body; // amount in PAISE (rupees * 100)
        if (!amount || isNaN(amount) || amount <= 0) {
            return res.status(400).json({ message: 'Invalid amount' });
        }

        const rzp = getRazorpay();
        if (!rzp) throw new Error('Razorpay client not initialized');

        const order = await rzp.orders.create({
            amount: Math.round(amount), // must be integer paise
            currency: 'INR',
            receipt: `rcpt_${Date.now()}`,
        });

        // Send back both order details AND the public key_id so the frontend
        // can open Razorpay checkout without hard-coding the key.
        res.json({
            orderId: order.id,
            amount: order.amount,
            currency: order.currency,
            keyId: process.env.RAZORPAY_KEY_ID
        });
    } catch (err: any) {
        console.error('[Razorpay] create-order error:', err);
        res.status(500).json({ message: err.error?.description || 'Failed to create Razorpay order' });
    }
});

// ─────────────────────────────────────────────
// RAZORPAY: Verify Payment & Complete Bill
// Called after the user successfully pays in the Razorpay popup.
// Verifies the HMAC signature, then creates the bill exactly like a
// regular cash/online payment would.
// ─────────────────────────────────────────────
router.post('/razorpay/verify-payment', auth, async (req, res) => {
    const session = await mongoose.startSession();
    session.startTransaction();

    try {
        const {
            razorpay_order_id,
            razorpay_payment_id,
            razorpay_signature,
            billData // same shape as the regular /bills POST body
        } = req.body;

        // 1. Verify HMAC-SHA256 signature
        const expectedSignature = crypto
            .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET!)
            .update(`${razorpay_order_id}|${razorpay_payment_id}`)
            .digest('hex');

        if (expectedSignature !== razorpay_signature) {
            throw new Error('Payment signature verification failed');
        }

        // 2. Signature valid → complete the bill (paymentType = 'online')
        if (!req.auth?.userId) throw new Error('Authentication required');
        const bill = await createBillInternal(
            session,
            { ...billData, paymentType: 'online' },
            req.auth.userId
        );

        await session.commitTransaction();
        res.status(201).json({ bill, razorpayPaymentId: razorpay_payment_id });
    } catch (err: any) {
        await session.abortTransaction();
        console.error('[Razorpay] verify-payment error:', err);
        res.status(400).json({ message: err.message });
    } finally {
        session.endSession();
    }
});

// Get all bills
router.get('/', auth, async (req, res) => {
    try {
        const bills = await Bill.find({ shopkeeperId: req.auth?.userId }).populate('customerId').sort({ createdAt: -1 });
        res.json(bills);
    } catch (err: any) {
        res.status(500).json({ message: err.message });
    }
});

export { router as billRouter };
